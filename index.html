<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ëë§ì‡ê¸° ê²Œì„</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Malgun Gothic', sans-serif;
            background-color: #f5f5f5;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }

        #header {
            background-color: #4a90e2;
            color: white;
            padding: 20px;
            text-align: center;
            font-size: 24px;
            font-weight: bold;
        }

        #main-container {
            display: flex;
            flex: 1;
            padding: 20px;
            gap: 20px;
            overflow: hidden;
        }

        #left-panel {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 10px;
            min-width: 0;
        }

        #right-panel {
            width: 320px;
            background: white;
            border: 1px solid #ddd;
            border-radius: 8px;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .panel {
            background: white;
            border: 1px solid #ddd;
            border-radius: 8px;
            padding: 15px;
        }

        #difficulty-frame {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        #difficulty-frame label {
            font-size: 18px;
            font-weight: bold;
        }

        #difficulty-slider {
            flex: 1;
            max-width: 200px;
        }

        #difficulty-value {
            font-size: 18px;
            font-weight: bold;
            color: #4a90e2;
            min-width: 30px;
        }

        #status-frame {
            text-align: center;
        }

        #status-label {
            font-size: 18px;
            color: #666;
            margin-bottom: 15px;
        }

        #timer-container {
            margin-top: 10px;
        }

        #timer-label {
            font-size: 16px;
            color: #c0392b;
            margin-bottom: 5px;
        }

        #timer-progress {
            width: 100%;
            height: 20px;
            background: #ecf0f1;
            border-radius: 10px;
            overflow: hidden;
        }

        #timer-bar {
            height: 100%;
            background: linear-gradient(90deg, #27ae60, #f39c12, #e74c3c);
            transition: width 0.3s ease;
        }

        #chat-frame {
            flex: 1;
            display: flex;
            flex-direction: column;
            min-height: 0;
        }

        #chat-frame h3 {
            font-size: 20px;
            margin-bottom: 10px;
        }

        #chat-text {
            flex: 1;
            background: #fafafa;
            border: 1px solid #ddd;
            border-radius: 4px;
            padding: 10px;
            overflow-y: auto;
            font-size: 16px;
            line-height: 1.6;
        }

        .chat-user {
            color: #2c5aa0;
            font-weight: bold;
        }

        .chat-bot {
            color: #e74c3c;
            font-weight: bold;
        }

        .chat-system {
            color: #7f8c8d;
            font-style: italic;
            font-size: 14px;
        }

        .word-link {
            color: #4a90e2;
            text-decoration: underline;
            cursor: pointer;
        }

        .word-link:hover {
            color: #2c5aa0;
        }

        #input-frame {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        #word-entry {
            flex: 1;
            font-size: 20px;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
            background: #fafafa;
        }

        #word-entry:disabled {
            background: #e0e0e0;
            cursor: not-allowed;
        }

        button {
            padding: 10px 20px;
            font-size: 18px;
            font-weight: bold;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            transition: opacity 0.2s;
        }

        button:hover:not(:disabled) {
            opacity: 0.9;
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        #submit-btn {
            background: #4a90e2;
            color: white;
        }

        #start-btn {
            background: #27ae60;
            color: white;
        }

        #forfeit-btn {
            background: #c0392b;
            color: white;
        }

        #hint-btn {
            background: #f1c40f;
            color: #2c3e50;
        }

        #hint-warning {
            font-size: 14px;
            color: #7f8c8d;
        }

        #button-frame {
            display: flex;
            gap: 10px;
            padding: 0 20px 20px;
            flex-wrap: wrap;
            align-items: center;
        }

        #stats-panel {
            background: #eef5ff;
            border: 1px solid #d0e4ff;
            border-radius: 8px;
            padding: 15px;
            margin: 10px;
        }

        #stats-panel h4 {
            font-size: 16px;
            margin-bottom: 10px;
            color: #2c3e50;
        }

        .stats-row {
            display: flex;
            justify-content: space-between;
            padding: 5px 10px;
            margin: 2px 0;
            border-radius: 4px;
            background: #eef5ff;
        }

        .stats-row.active {
            background: #d6eaff;
        }

        .stats-level {
            font-weight: bold;
            font-size: 13px;
            color: #2c3e50;
        }

        .stats-value {
            font-size: 12px;
            color: #2c3e50;
        }

        #info-section {
            flex: 1;
            display: flex;
            flex-direction: column;
            padding: 10px;
            overflow: hidden;
        }

        #info-section h3 {
            font-size: 20px;
            margin-bottom: 10px;
        }

        #info-text {
            flex: 1;
            background: #fafafa;
            border: 1px solid #ddd;
            border-radius: 4px;
            padding: 10px;
            overflow-y: auto;
            font-size: 14px;
            line-height: 1.6;
        }

        hr {
            border: none;
            border-top: 1px solid #ddd;
            margin: 10px 0;
        }
    </style>
</head>
<body>
    <div id="header">ğŸ® ëë§ì‡ê¸° ê²Œì„</div>

    <div id="main-container">
        <div id="left-panel">
            <div class="panel" id="difficulty-frame">
                <label>ë´‡ ë‚œì´ë„:</label>
                <input type="range" id="difficulty-slider" min="1" max="5" value="3" step="1">
                <span id="difficulty-value">3</span>
            </div>

            <div class="panel" id="status-frame">
                <div id="status-label">'ì‹œì‘' ë²„íŠ¼ì„ ëˆŒëŸ¬ ê²Œì„ì„ ì‹œì‘í•˜ì„¸ìš”</div>
                <div id="timer-container">
                    <div id="timer-label">ë‚¨ì€ ì‹œê°„: --</div>
                    <div id="timer-progress">
                        <div id="timer-bar" style="width: 0%"></div>
                    </div>
                </div>
            </div>

            <div class="panel" id="chat-frame">
                <h3>ê²Œì„ ì§„í–‰</h3>
                <div id="chat-text"></div>
            </div>

            <div class="panel" id="input-frame">
                <input type="text" id="word-entry" placeholder="ë‹¨ì–´ë¥¼ ì…ë ¥í•˜ì„¸ìš”" disabled>
                <button id="submit-btn">ì œì¶œ</button>
            </div>
        </div>

        <div id="right-panel">
            <div id="stats-panel">
                <h4>ë‚œì´ë„ë³„ ì „ì </h4>
                <div id="stats-rows"></div>
            </div>
            <hr>
            <div id="info-section">
                <h3>ë‹¨ì–´ ì •ë³´</h3>
                <div id="info-text"></div>
            </div>
        </div>
    </div>

    <div id="button-frame">
        <button id="start-btn">ê²Œì„ ì‹œì‘</button>
        <button id="hint-btn">íŒíŠ¸</button>
        <span id="hint-warning">íŒíŠ¸ ì‚¬ìš© ì‹œ ìŠ¹ë¦¬ ê¸°ë¡ì´ ì˜¬ë¼ê°€ì§€ ì•ŠìŠµë‹ˆë‹¤.</span>
        <button id="forfeit-btn">í¬ê¸°</button>
    </div>

    <script>
        // í•œê¸€ ìœ ë‹ˆì½”ë“œ ì²˜ë¦¬
        const HANGUL_BASE = 0xAC00;
        const CHOS = ['ã„±', 'ã„²', 'ã„´', 'ã„·', 'ã„¸', 'ã„¹', 'ã…', 'ã…‚', 'ã…ƒ', 'ã……', 'ã…†', 'ã…‡', 'ã…ˆ', 'ã…‰', 'ã…Š', 'ã…‹', 'ã…Œ', 'ã…', 'ã…'];
        const JUNGS = ['ã…', 'ã…', 'ã…‘', 'ã…’', 'ã…“', 'ã…”', 'ã…•', 'ã…–', 'ã…—', 'ã…˜', 'ã…™', 'ã…š', 'ã…›', 'ã…œ', 'ã…', 'ã…', 'ã…Ÿ', 'ã… ', 'ã…¡', 'ã…¢', 'ã…£'];
        const JONGS = ['', 'ã„±', 'ã„²', 'ã„³', 'ã„´', 'ã„µ', 'ã„¶', 'ã„·', 'ã„¹', 'ã„º', 'ã„»', 'ã„¼', 'ã„½', 'ã„¾', 'ã„¿', 'ã…€', 'ã…', 'ã…‚', 'ã…„', 'ã……', 'ã…†', 'ã…‡', 'ã…ˆ', 'ã…Š', 'ã…‹', 'ã…Œ', 'ã…', 'ã…'];
        const CHO_N = 2;
        const CHO_R = 5;
        const CHO_YIEUNG = 11;
        const IY_JUNG_IDX = new Set([20, 2, 6, 12, 17, 7, 16, 3, 19]);

        function isHangulSyllable(ch) {
            if (!ch) return false;
            const code = ch.charCodeAt(0);
            return code >= 0xAC00 && code <= 0xD7A3;
        }

        function decompose(ch) {
            if (!isHangulSyllable(ch)) return null;
            const code = ch.charCodeAt(0) - HANGUL_BASE;
            const cho = Math.floor(code / 588);
            const jung = Math.floor((code % 588) / 28);
            const jong = code % 28;
            return { cho, jung, jong };
        }

        function compose(cho, jung, jong) {
            return String.fromCharCode(HANGUL_BASE + cho * 588 + jung * 28 + jong);
        }

        function dueumTransform(syll) {
            const decomp = decompose(syll);
            if (!decomp) return null;

            const { cho, jung, jong } = decomp;
            if (cho === CHO_N) {
                if (IY_JUNG_IDX.has(jung)) {
                    return compose(CHO_YIEUNG, jung, jong);
                }
                return null;
            }

            if (cho === CHO_R) {
                if (IY_JUNG_IDX.has(jung)) {
                    return compose(CHO_YIEUNG, jung, jong);
                }
                return compose(CHO_N, jung, jong);
            }

            return null;
        }

        function getInitialConsonants(word) {
            let result = '';
            for (const ch of word) {
                const decomp = decompose(ch);
                if (!decomp) {
                    result += ch;
                } else {
                    result += CHOS[decomp.cho];
                }
            }
            return result;
        }

        function getDueumVariants(syllable) {
            if (!syllable) return new Set();
            const variants = new Set([syllable]);
            const transformed = dueumTransform(syllable);
            if (transformed) variants.add(transformed);
            return variants;
        }

        // ê²Œì„ ìƒíƒœ
        const game = {
            wordsData: {},
            wordsByFirstChar: {},
            wordsByLastCharVariants: {},
            usedWords: new Set(),
            gameHistory: [],
            currentLastChar: '',
            botDifficulty: 3,
            baseTurnTimeLimit: 30,
            turnTimeLimit: 30,
            timerSecondsRemaining: 0,
            timerIntervalId: null,
            pendingBotTimeoutId: null,
            botTurnSequence: 0,
            gameActive: false,
            statsFile: 'game_stats',
            winCount: 0,
            lossCount: 0,
            statsByDifficulty: {},
            activeGameDifficulty: null,
            hintUsedInGame: false
        };

        // ë‚œì´ë„ë³„ ì „ì  ì´ˆê¸°í™”
        for (let i = 1; i <= 5; i++) {
            game.statsByDifficulty[i] = { wins: 0, losses: 0 };
        }

        // DOM ìš”ì†Œ
        const els = {
            difficultySlider: document.getElementById('difficulty-slider'),
            difficultyValue: document.getElementById('difficulty-value'),
            statusLabel: document.getElementById('status-label'),
            timerLabel: document.getElementById('timer-label'),
            timerBar: document.getElementById('timer-bar'),
            chatText: document.getElementById('chat-text'),
            wordEntry: document.getElementById('word-entry'),
            submitBtn: document.getElementById('submit-btn'),
            startBtn: document.getElementById('start-btn'),
            hintBtn: document.getElementById('hint-btn'),
            forfeitBtn: document.getElementById('forfeit-btn'),
            infoText: document.getElementById('info-text'),
            statsRows: document.getElementById('stats-rows'),
            hintWarning: document.getElementById('hint-warning')
        };

        // ì´ˆê¸°í™”
        function init() {
            loadStats();
            createStatsRows();
            refreshDifficultyStatsPanel();
            loadWords();
            updateHintNotice();

            els.difficultySlider.addEventListener('input', onDifficultyChange);
            els.submitBtn.addEventListener('click', submitWord);
            els.wordEntry.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') submitWord();
            });
            els.startBtn.addEventListener('click', startGame);
            els.forfeitBtn.addEventListener('click', forfeitGame);
            if (els.hintBtn) {
                els.hintBtn.addEventListener('click', () => useHint());
            }
        }

        function createStatsRows() {
            els.statsRows.innerHTML = '';
            for (let level = 1; level <= 5; level++) {
                const row = document.createElement('div');
                row.className = 'stats-row';
                row.dataset.level = level;
                
                const levelLabel = document.createElement('span');
                levelLabel.className = 'stats-level';
                levelLabel.textContent = `${level}ë‹¨ê³„`;
                
                const valueLabel = document.createElement('span');
                valueLabel.className = 'stats-value';
                valueLabel.textContent = 'ìŠ¹ë¦¬ 0 | íŒ¨ë°° 0';
                
                row.appendChild(levelLabel);
                row.appendChild(valueLabel);
                els.statsRows.appendChild(row);
            }
        }

        function refreshDifficultyStatsPanel() {
            const rows = els.statsRows.querySelectorAll('.stats-row');
            rows.forEach(row => {
                const level = parseInt(row.dataset.level);
                const stats = game.statsByDifficulty[level] || { wins: 0, losses: 0 };
                const valueLabel = row.querySelector('.stats-value');
                valueLabel.textContent = `ìŠ¹ë¦¬ ${stats.wins} | íŒ¨ë°° ${stats.losses}`;
                
                if (level === game.botDifficulty) {
                    row.classList.add('active');
                } else {
                    row.classList.remove('active');
                }
            });
        }

        function loadStats() {
            try {
                const data = JSON.parse(localStorage.getItem(game.statsFile) || '{}');
                game.winCount = parseInt(data.wins || 0);
                game.lossCount = parseInt(data.losses || 0);
                
                const byDifficulty = data.by_difficulty || {};
                for (let level = 1; level <= 5; level++) {
                    const stats = byDifficulty[level] || { wins: 0, losses: 0 };
                    game.statsByDifficulty[level] = {
                        wins: parseInt(stats.wins || 0),
                        losses: parseInt(stats.losses || 0)
                    };
                }
            } catch (e) {
                console.error('Failed to load stats:', e);
            }
        }

        function saveStats() {
            try {
                const data = {
                    wins: game.winCount,
                    losses: game.lossCount,
                    by_difficulty: {}
                };
                
                for (let level = 1; level <= 5; level++) {
                    data.by_difficulty[level] = game.statsByDifficulty[level];
                }
                
                localStorage.setItem(game.statsFile, JSON.stringify(data));
            } catch (e) {
                console.error('Failed to save stats:', e);
            }
        }

        function updateStats(wins = 0, losses = 0, difficulty = null) {
            if (wins > 0 && game.hintUsedInGame) {
                wins = 0;
            }

            if (wins === 0 && losses === 0) {
                game.activeGameDifficulty = null;
                return;
            }

            game.winCount += wins;
            game.lossCount += losses;
            
            const diff = difficulty || game.activeGameDifficulty || game.botDifficulty;
            if (diff >= 1 && diff <= 5) {
                game.statsByDifficulty[diff].wins += wins;
                game.statsByDifficulty[diff].losses += losses;
            }
            
            refreshDifficultyStatsPanel();
            saveStats();
            game.activeGameDifficulty = null;
        }

        function updateHintNotice() {
            if (!els.hintWarning) return;

            if (game.hintUsedInGame) {
                els.hintWarning.textContent = 'íŒíŠ¸ ì‚¬ìš©ë¨: ì´ë²ˆ ê²Œì„ì—ì„œëŠ” ìŠ¹ë¦¬ ê¸°ë¡ì´ ì˜¬ë¼ê°€ì§€ ì•ŠìŠµë‹ˆë‹¤.';
                els.hintWarning.style.color = '#c0392b';
            } else {
                els.hintWarning.textContent = 'íŒíŠ¸ ì‚¬ìš© ì‹œ ìŠ¹ë¦¬ ê¸°ë¡ì´ ì˜¬ë¼ê°€ì§€ ì•ŠìŠµë‹ˆë‹¤.';
                els.hintWarning.style.color = '#7f8c8d';
            }
        }

        function useHint(limit = 10) {
            if (!game.gameActive) {
                addSystemMessage('ê²Œì„ì„ ì‹œì‘í•œ í›„ì— íŒíŠ¸ë¥¼ ì‚¬ìš©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.');
                return;
            }

            const firstUse = !game.hintUsedInGame;
            game.hintUsedInGame = true;
            updateHintNotice();

            if (firstUse) {
                addSystemMessage('íŒíŠ¸ë¥¼ ì‚¬ìš©í•˜ë©´ ì´ë²ˆ ê²Œì„ì˜ ìŠ¹ë¦¬ ê¸°ë¡ì€ ì˜¬ë¼ê°€ì§€ ì•ŠìŠµë‹ˆë‹¤.');
            }

            showPossibleUserWords(limit, { initialsOnly: true });
        }

        async function loadWords() {
            try {
                const response = await fetch('words.json');
                game.wordsData = await response.json();
                buildWordIndexes();
                addSystemMessage(`âœ“ ì‚¬ì „ ë¡œë“œ ì™„ë£Œ: ${Object.keys(game.wordsData).length}ê°œ ë‹¨ì–´`);
            } catch (e) {
                showWarningMessage('words.json íŒŒì¼ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.');
            }
        }

        function buildWordIndexes() {
            game.wordsByFirstChar = {};
            game.wordsByLastCharVariants = {};
            
            for (const word in game.wordsData) {
                const firstChar = word[0];
                if (!game.wordsByFirstChar[firstChar]) {
                    game.wordsByFirstChar[firstChar] = [];
                }
                game.wordsByFirstChar[firstChar].push(word);
                
                const lastChar = word[word.length - 1];
                const variants = getDueumVariants(lastChar);
                variants.forEach(variant => {
                    if (!game.wordsByLastCharVariants[variant]) {
                        game.wordsByLastCharVariants[variant] = new Set();
                    }
                    game.wordsByLastCharVariants[variant].add(word);
                });
            }
        }

        function onDifficultyChange() {
            const value = parseInt(els.difficultySlider.value);
            game.botDifficulty = value;
            els.difficultyValue.textContent = value;
            updateTurnTimeLimit();
            refreshDifficultyStatsPanel();
        }

        function getEffectiveDifficulty() {
            return game.botDifficulty + 5;
        }

        function updateTurnTimeLimit() {
            const extraTime = getEffectiveDifficulty() >= 10 ? 0 : 0;
            game.turnTimeLimit = game.baseTurnTimeLimit + extraTime;
        }

        function startGame() {
            resetGame();
            game.activeGameDifficulty = game.botDifficulty;
            addSystemMessage(`${game.botDifficulty}ë‹¨ê³„ ë´‡ê³¼ì˜ ê²Œì„ì´ ì‹œì‘ë˜ì—ˆìŠµë‹ˆë‹¤! ì•„ë¬´ ë‹¨ì–´ë‚˜ ì…ë ¥í•˜ì„¸ìš”.`);
            els.statusLabel.textContent = 'ë‹¹ì‹ ì˜ ì°¨ë¡€ì…ë‹ˆë‹¤';
            els.statusLabel.style.color = '#27ae60';
            els.wordEntry.disabled = false;
            els.wordEntry.focus();
            game.gameActive = true;
            startTimer();
        }

        function resetGame() {
            game.gameActive = false;
            game.activeGameDifficulty = null;
            cancelPendingBotTurn();
            invalidateBotTurn();
            game.usedWords.clear();
            game.gameHistory = [];
            game.currentLastChar = '';
            game.hintUsedInGame = false;
            updateHintNotice();

            stopTimer();
            resetTimerDisplay();
            
            els.chatText.innerHTML = '';
            els.infoText.innerHTML = '';
            els.wordEntry.value = '';
            els.wordEntry.disabled = false;
            
            // ì´ìŒ ìˆ˜ ë³µì›
            loadWords();
        }

        function addSystemMessage(message) {
            const div = document.createElement('div');
            div.className = 'chat-system';
            div.textContent = `[ì‹œìŠ¤í…œ] ${message}`;
            els.chatText.appendChild(div);
            els.chatText.scrollTop = els.chatText.scrollHeight;
        }

        function addSystemMessageWithWordLinks(prefix, words) {
            if (!words || words.length === 0) {
                addSystemMessage(prefix.trim());
                return;
            }
            
            const div = document.createElement('div');
            div.className = 'chat-system';
            
            const systemLabel = document.createElement('span');
            systemLabel.textContent = '[ì‹œìŠ¤í…œ] ' + prefix;
            div.appendChild(systemLabel);
            
            words.forEach((word, idx) => {
                if (idx > 0) {
                    div.appendChild(document.createTextNode(', '));
                }
                
                const link = document.createElement('span');
                link.className = 'word-link';
                link.textContent = word;
                link.onclick = () => showWordInfo(word);
                div.appendChild(link);
            });
            
            els.chatText.appendChild(div);
            els.chatText.scrollTop = els.chatText.scrollHeight;
        }

        function showWarningMessage(message) {
            addSystemMessage(`âš ï¸ ${message}`);
            els.statusLabel.textContent = message;
            els.statusLabel.style.color = '#c0392b';
        }

        function addWordMessage(speaker, word) {
            const div = document.createElement('div');
            
            const label = document.createElement('span');
            label.className = speaker === 'user' ? 'chat-user' : 'chat-bot';
            label.textContent = speaker === 'user' ? 'ë‹¹ì‹ : ' : 'ë´‡: ';
            div.appendChild(label);
            
            const link = document.createElement('span');
            link.className = 'word-link';
            link.textContent = word;
            link.onclick = () => showWordInfo(word);
            div.appendChild(link);
            
            els.chatText.appendChild(div);
            els.chatText.scrollTop = els.chatText.scrollHeight;
        }

        function showWordInfo(word) {
            els.infoText.innerHTML = '';
            
            if (game.wordsData[word]) {
                const title = document.createElement('div');
                title.style.fontSize = '18px';
                title.style.fontWeight = 'bold';
                title.style.marginBottom = '10px';
                title.textContent = `ğŸ“– ${word}`;
                els.infoText.appendChild(title);
                
                game.wordsData[word].forEach((entry, idx) => {
                    const section = document.createElement('div');
                    section.style.marginBottom = '15px';
                    
                    section.innerHTML = `
                        <div style="font-weight: bold; margin-bottom: 5px;">[ì˜ë¯¸ ${idx + 1}]</div>
                        <div>ë°œìŒ: ${entry['ë°œìŒ'] || '-'}</div>
                        <div>êµ¬ë¶„: ${entry['ê³ ìœ ì–´ ì—¬ë¶€'] || '-'}</div>
                        <div>ëœ»: ${entry['ëœ»í’€ì´'] || '-'}</div>
                        ${entry['ì „ë¬¸ ë¶„ì•¼'] ? `<div>ë¶„ì•¼: ${entry['ì „ë¬¸ ë¶„ì•¼']}</div>` : ''}
                        ${entry['ìš©ë¡€'] ? `<div style="margin-top: 5px;">ìš©ë¡€:<br>${entry['ìš©ë¡€']}</div>` : ''}
                    `;
                    
                    els.infoText.appendChild(section);
                    
                    if (idx < game.wordsData[word].length - 1) {
                        const hr = document.createElement('hr');
                        els.infoText.appendChild(hr);
                    }
                });
            } else {
                els.infoText.textContent = `'${word}' ë‹¨ì–´ ì •ë³´ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.`;
            }
        }

        function applyDueumDecrease(char) {
            if (!char) return;
            
            const words = game.wordsByLastCharVariants[char];
            if (!words) return;
            
            words.forEach(word => {
                const entries = game.wordsData[word];
                if (entries) {
                    entries.forEach(entry => {
                        if ('ì´ìŒ ìˆ˜' in entry) {
                            entry['ì´ìŒ ìˆ˜'] = Math.max(0, entry['ì´ìŒ ìˆ˜'] - 1);
                        }
                    });
                }
            });
        }

        function countAvailableFollowups(lastChar, excludeWord = null, usedWords = null) {
            if (!lastChar) return 0;
            
            const allowedChars = getDueumVariants(lastChar);
            const used = usedWords || game.usedWords;
            const availableWords = new Set();
            
            allowedChars.forEach(char => {
                const words = game.wordsByFirstChar[char] || [];
                words.forEach(word => {
                    if (word === excludeWord || used.has(word)) return;
                    availableWords.add(word);
                });
            });
            
            return availableWords.size;
        }

        function getPossibleUserWords(limit = 10) {
            if (!game.currentLastChar) return [];
            
            const allowedChars = getDueumVariants(game.currentLastChar);
            const candidates = [];
            const seen = new Set();
            
            allowedChars.forEach(char => {
                const words = game.wordsByFirstChar[char] || [];
                words.forEach(word => {
                    if (game.usedWords.has(word) || seen.has(word)) return;
                    seen.add(word);
                    
                    const entries = game.wordsData[word];
                    const maxEuem = Math.max(...entries.map(e => e['ì´ìŒ ìˆ˜'] || 0));
                    
                    if (game.gameHistory.length < 4 && maxEuem === 0) return;
                    
                    candidates.push({ word, maxEuem });
                });
            });
            
            candidates.sort((a, b) => b.maxEuem - a.maxEuem || a.word.localeCompare(b.word));
            return candidates.slice(0, limit).map(c => c.word);
        }

        function showPossibleUserWords(limit = 10, options = {}) {
            const { initialsOnly = false } = options;
            const suggestions = getPossibleUserWords(limit);

            if (!game.currentLastChar) {
                if (initialsOnly) {
                    addSystemMessage('ì•„ì§ íŒíŠ¸ë¥¼ ì œê³µí•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤. ë¨¼ì € ë‹¨ì–´ë¥¼ ì…ë ¥í•´ ì£¼ì„¸ìš”.');
                }
                return;
            }

            if (suggestions.length === 0) {
                addSystemMessage('ì‚¬ìš©ìê°€ ë§í•  ìˆ˜ ìˆëŠ” ë‹¨ì–´ê°€ ì—†ì—ˆìŠµë‹ˆë‹¤.');
                return;
            }

            if (initialsOnly) {
                const hints = suggestions.map(getInitialConsonants);
                addSystemMessage(`ê°€ëŠ¥í•œ ë‹¨ì–´ ì´ˆì„± íŒíŠ¸ (ìµœëŒ€ ${limit}ê°œ í‘œì‹œë¨): ${hints.join(', ')}`);
                return;
            }

            const prefix = `ì‚¬ìš©ìê°€ ë§í•  ìˆ˜ ìˆì—ˆë˜ ë‹¨ì–´ ì˜ˆì‹œ (ìµœëŒ€ ${limit}ê°œ í‘œì‹œë¨): `;
            addSystemMessageWithWordLinks(prefix, suggestions);
        }

        function submitWord() {
            if (!game.gameActive) return;
            
            const word = els.wordEntry.value.trim();
            els.wordEntry.value = '';
            
            if (!word) return;
            
            // ë‹¨ì–´ ê²€ì¦
            if (!isHangulSyllable(word[0]) || !isHangulSyllable(word[word.length - 1])) {
                showWarningMessage(`${word}(ì€)ëŠ” ì˜ëª»ëœ ë‹¨ì–´ì…ë‹ˆë‹¤: í•œê¸€ë¡œ ì‹œì‘í•˜ê³  ëë‚˜ì•¼ í•©ë‹ˆë‹¤.`);
                return;
            }
            
            if (word.length < 2) {
                showWarningMessage(`${word}(ì€)ëŠ” ì˜ëª»ëœ ë‹¨ì–´ì…ë‹ˆë‹¤: ìµœì†Œ 2ê¸€ì ì´ìƒì´ì–´ì•¼ í•©ë‹ˆë‹¤.`);
                return;
            }
            
            if (!game.wordsData[word]) {
                showWarningMessage(`${word}(ì€)ëŠ” ì˜ëª»ëœ ë‹¨ì–´ì…ë‹ˆë‹¤: ì‚¬ì „ì— ì—†ëŠ” ë‹¨ì–´ì´ê±°ë‚˜ ëª…ì‚¬ê°€ ì•„ë‹™ë‹ˆë‹¤.`);
                return;
            }
            
            const maxEuem = Math.max(...game.wordsData[word].map(e => e['ì´ìŒ ìˆ˜'] || 0));
            if (game.gameHistory.length < 4 && maxEuem === 0) {
                showWarningMessage(`${word}(ì€)ëŠ” ì˜ëª»ëœ ë‹¨ì–´ì…ë‹ˆë‹¤: ê²Œì„ ì‹œì‘ í›„ 4í„´ê¹Œì§€ëŠ” ì´ìŒ ìˆ˜ê°€ 0ì¸ ë‹¨ì–´ë¥¼ ì‚¬ìš©í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.`);
                return;
            }
            
            if (game.usedWords.has(word)) {
                showWarningMessage(`${word}(ì€)ëŠ” ì˜ëª»ëœ ë‹¨ì–´ì…ë‹ˆë‹¤: ì´ë¯¸ ì‚¬ìš©ëœ ë‹¨ì–´ì…ë‹ˆë‹¤.`);
                return;
            }
            
            const firstChar = word[0];
            
            // ì²« ë‹¨ì–´ê°€ ì•„ë‹ˆë©´ ëë§ì‡ê¸° ê·œì¹™ ê²€ì‚¬
            if (game.currentLastChar) {
                const allowedChars = getDueumVariants(game.currentLastChar);
                if (!allowedChars.has(firstChar)) {
                    showWarningMessage(`${word}(ì€)ëŠ” ì˜ëª»ëœ ë‹¨ì–´ì…ë‹ˆë‹¤: '${game.currentLastChar}'(ìœ¼)ë¡œ ì‹œì‘í•˜ëŠ” ë‹¨ì–´ë¥¼ ì…ë ¥í•˜ì„¸ìš”.`);
                    return;
                }
            }
            
            // ë‹¨ì–´ ì¶”ê°€
            game.usedWords.add(word);
            game.gameHistory.push(['user', word]);
            addWordMessage('user', word);
            
            stopTimer();
            
            // ë§ˆì§€ë§‰ ê¸€ì ì—…ë°ì´íŠ¸
            const lastChar = word[word.length - 1];
            game.currentLastChar = lastChar;
            
            // ì´ìŒ ìˆ˜ ê°ì†Œ
            applyDueumDecrease(firstChar);
            
            // ë´‡ ì°¨ë¡€
            els.statusLabel.textContent = 'ë´‡ì´ ìƒê° ì¤‘...';
            els.statusLabel.style.color = '#e67e22';
            els.wordEntry.disabled = true;
            
            cancelPendingBotTurn();
            const turnId = invalidateBotTurn();
            game.pendingBotTimeoutId = setTimeout(() => botTurn(turnId), 1000);
        }

        function cancelPendingBotTurn() {
            if (game.pendingBotTimeoutId !== null) {
                clearTimeout(game.pendingBotTimeoutId);
                game.pendingBotTimeoutId = null;
            }
        }

        function invalidateBotTurn() {
            game.botTurnSequence++;
            return game.botTurnSequence;
        }

        function botTurn(turnId) {
            game.pendingBotTimeoutId = null;
            if (turnId !== game.botTurnSequence || !game.gameActive) return;
            
            setTimeout(() => {
                const result = computeBotDecision();
                applyBotResult(turnId, result);
            }, 0);
        }

        function computeBotDecision() {
            const possibleWords = [];
            const usedWordsSnapshot = new Set(game.usedWords);
            const gameHistorySnapshot = [...game.gameHistory];
            const lastRequiredChar = game.currentLastChar;
            
            if (gameHistorySnapshot.length === 0) {
                return { type: 'no_word' };
            }
            
            let allowedChars = null;
            if (lastRequiredChar) {
                allowedChars = getDueumVariants(lastRequiredChar);
            }
            
            for (const word in game.wordsData) {
                if (usedWordsSnapshot.has(word)) continue;
                
                const firstChar = word[0];
                if (allowedChars !== null && !allowedChars.has(firstChar)) continue;
                
                const entries = game.wordsData[word];
                const maxEuem = Math.max(...entries.map(e => e['ì´ìŒ ìˆ˜'] || 0));
                
                if (gameHistorySnapshot.length < 4 && maxEuem === 0) continue;
                
                const minThreshold = Math.max(0, 3200 - (getEffectiveDifficulty() * 400));
                if (maxEuem < minThreshold) continue;
                
                possibleWords.push({ word, maxEuem });
            }
            
            if (possibleWords.length === 0) {
                return { type: 'no_word' };
            }
            
            // ì•ˆì „í•œ ë‹¨ì–´ë§Œ ì„ íƒ
            const safeWords = possibleWords.filter(({ word }) => {
                const lastChar = word[word.length - 1];
                const remaining = countAvailableFollowups(lastChar, word, usedWordsSnapshot);
                return remaining > 0;
            });
            
            if (safeWords.length > 0) {
                possibleWords.length = 0;
                possibleWords.push(...safeWords);
            }
            
            // ë‚œì´ë„ì— ë”°ë¥¸ ì‹¤íŒ¨ í™•ë¥ 
            const lastUserWord = gameHistorySnapshot[gameHistorySnapshot.length - 1][1];
            const lastEuem = Math.max(...game.wordsData[lastUserWord].map(e => e['ì´ìŒ ìˆ˜'] || 0));
            
            let baseProb = 1.0;
            if (lastEuem < 1000) {
                const difficultyFactor = getEffectiveDifficulty() / 10.0;
                const euemFactor = lastEuem / 1000.0;
                
                const baseSkill = 0.35 + (0.65 * difficultyFactor);
                const penaltyScale = Math.pow(1 - difficultyFactor, 3);
                const lowEuemPenalty = (1 - euemFactor) * 0.4 * penaltyScale;
                const euemBonus = euemFactor * 0.25 * (1 - penaltyScale);
                
                baseProb = baseSkill - lowEuemPenalty + euemBonus;
                baseProb = Math.max(0.1, Math.min(1.0, baseProb));
            }
            
            let shouldFail = false;
            if (getEffectiveDifficulty() < 10) {
                shouldFail = Math.random() > baseProb;
            }
            
            if (shouldFail) {
                return { type: 'fail', baseProb };
            }
            
            // ë‹¨ì–´ ì„ íƒ
            const minEuem = Math.min(...possibleWords.map(p => p.maxEuem));
            const maxEuemVal = Math.max(...possibleWords.map(p => p.maxEuem));
            const difficultyFactor = getEffectiveDifficulty() / 10.0;
            
            let selectedWord;
            if (getEffectiveDifficulty() >= 10) {
                const minCandidates = possibleWords.filter(p => p.maxEuem === minEuem);
                selectedWord = minCandidates[Math.floor(Math.random() * minCandidates.length)].word;
            } else {
                if (maxEuemVal === minEuem) {
                    selectedWord = possibleWords[Math.floor(Math.random() * possibleWords.length)].word;
                } else {
                    const weights = possibleWords.map(({ maxEuem }) => {
                        const normalized = (maxEuem - minEuem) / (maxEuemVal - minEuem);
                        const highPref = (1.0 - difficultyFactor) * normalized;
                        const lowPref = difficultyFactor * (1.0 - normalized);
                        return highPref + lowPref + 0.05;
                    });
                    
                    const totalWeight = weights.reduce((a, b) => a + b, 0);
                    let random = Math.random() * totalWeight;
                    
                    for (let i = 0; i < possibleWords.length; i++) {
                        random -= weights[i];
                        if (random <= 0) {
                            selectedWord = possibleWords[i].word;
                            break;
                        }
                    }
                    
                    if (!selectedWord) {
                        selectedWord = possibleWords[possibleWords.length - 1].word;
                    }
                }
            }
            
            return {
                type: 'word',
                word: selectedWord,
                firstChar: selectedWord[0],
                lastChar: selectedWord[selectedWord.length - 1]
            };
        }

        function applyBotResult(turnId, result) {
            if (turnId !== game.botTurnSequence || !game.gameActive) return;
            
            const outcome = result.type;
            
            if (outcome === 'no_word') {
                addSystemMessage('ë´‡ì´ ë§í•  ìˆ˜ ìˆëŠ” ë‹¨ì–´ê°€ ì—†ìŠµë‹ˆë‹¤. ë‹¹ì‹ ì˜ ìŠ¹ë¦¬!');
                els.statusLabel.textContent = 'ê²Œì„ ì¢…ë£Œ - ë‹¹ì‹ ì˜ ìŠ¹ë¦¬! ğŸ‰';
                els.statusLabel.style.color = '#27ae60';
                els.wordEntry.disabled = true;
                game.gameActive = false;
                stopTimer();
                resetTimerDisplay();
                updateStats(1, 0);
                return;
            }
            
            if (outcome === 'fail') {
                addSystemMessage('ë´‡ì´ ë‹¨ì–´ë¥¼ ì°¾ì§€ ëª»í–ˆìŠµë‹ˆë‹¤. ë‹¹ì‹ ì˜ ìŠ¹ë¦¬!');
                els.statusLabel.textContent = 'ê²Œì„ ì¢…ë£Œ - ë‹¹ì‹ ì˜ ìŠ¹ë¦¬! ğŸ‰';
                els.statusLabel.style.color = '#27ae60';
                els.wordEntry.disabled = true;
                game.gameActive = false;
                stopTimer();
                resetTimerDisplay();
                updateStats(1, 0);
                return;
            }
            
            if (outcome !== 'word') return;
            
            const selectedWord = result.word;
            if (!selectedWord) return;
            
            const selectedFirstChar = result.firstChar;
            const lastChar = result.lastChar;
            
            game.usedWords.add(selectedWord);
            game.gameHistory.push(['bot', selectedWord]);
            addWordMessage('bot', selectedWord);
            
            game.currentLastChar = lastChar;
            applyDueumDecrease(selectedFirstChar);
            
            els.statusLabel.textContent = `'${lastChar}'(ìœ¼)ë¡œ ì‹œì‘í•˜ëŠ” ë‹¨ì–´ë¥¼ ì…ë ¥í•˜ì„¸ìš”`;
            els.statusLabel.style.color = '#2c5aa0';
            els.wordEntry.disabled = false;
            els.wordEntry.focus();
            
            if (game.gameActive) {
                startTimer();
            }
        }

        function startTimer() {
            stopTimer();
            updateTurnTimeLimit();
            game.timerSecondsRemaining = game.turnTimeLimit;
            updateTimerDisplay();
            game.timerIntervalId = setInterval(updateTimer, 1000);
        }

        function stopTimer() {
            if (game.timerIntervalId !== null) {
                clearInterval(game.timerIntervalId);
                game.timerIntervalId = null;
            }
        }

        function updateTimer() {
            if (game.timerSecondsRemaining <= 0) return;
            
            game.timerSecondsRemaining--;
            updateTimerDisplay();
            
            if (game.timerSecondsRemaining <= 0) {
                handleTimeOut();
            }
        }

        function updateTimerDisplay() {
            if (game.timerSecondsRemaining > 0) {
                els.timerLabel.textContent = `ë‚¨ì€ ì‹œê°„: ${String(game.timerSecondsRemaining).padStart(2, '0')}ì´ˆ`;
                const percentage = (game.timerSecondsRemaining / game.turnTimeLimit) * 100;
                els.timerBar.style.width = `${percentage}%`;
            } else {
                els.timerLabel.textContent = 'ë‚¨ì€ ì‹œê°„: 00ì´ˆ';
                els.timerBar.style.width = '0%';
            }
        }

        function resetTimerDisplay() {
            game.timerSecondsRemaining = 0;
            els.timerLabel.textContent = 'ë‚¨ì€ ì‹œê°„: --';
            els.timerBar.style.width = '0%';
        }

        function handleTimeOut() {
            if (!game.gameActive) return;
            
            game.gameActive = false;
            cancelPendingBotTurn();
            invalidateBotTurn();
            stopTimer();
            els.wordEntry.disabled = true;
            els.statusLabel.textContent = 'ê²Œì„ ì¢…ë£Œ - ì‹œê°„ ì´ˆê³¼! â°';
            els.statusLabel.style.color = '#c0392b';
            addSystemMessage('ì‹œê°„ ì´ˆê³¼! ë´‡ì˜ ìŠ¹ë¦¬ì…ë‹ˆë‹¤.');
            showPossibleUserWords();
            updateStats(0, 1);
        }

        function forfeitGame() {
            if (!game.gameActive) return;
            
            game.gameActive = false;
            cancelPendingBotTurn();
            invalidateBotTurn();
            stopTimer();
            els.wordEntry.disabled = true;
            els.statusLabel.textContent = 'ê²Œì„ ì¢…ë£Œ - ë‹¹ì‹ ì˜ íŒ¨ë°°';
            els.statusLabel.style.color = '#c0392b';
            addSystemMessage('ë‹¹ì‹ ì´ ê¸°ê¶Œí–ˆìŠµë‹ˆë‹¤. ë´‡ì˜ ìŠ¹ë¦¬!');
            showPossibleUserWords();
            resetTimerDisplay();
            updateStats(0, 1);
        }

        // ì´ˆê¸°í™” ì‹¤í–‰
        init();
    </script>
</body>
</html>
